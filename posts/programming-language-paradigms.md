---
title: 'Clean Architectureを6章まで読んだ'
date: '2022-02-13'
---

[Clean Architecture](https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656)の６章までを読んでいて、構造化プログラミング、オブジェクト思考プログラミング、関数型プログラミングに対する理解が浅いと思った。調べながら読んだ内容を雑にまとめた。

# 構造化プログラミング

## 特徴

- `goto`文の禁止
- 順次（順次進行）、選択（条件分岐）、反復（繰り返し処理）で構成する

`goto`文を乱用するとプログラム間を行ったり来たりすることになりプログラムが複雑化してしまう。`goto`文を禁止することで **上から下へ** というプログラミングの順次進行性を担保することができる。それに加えて`if`（選択）文や`for`（反復）文といった制御構造を使うことで、証明可能な単位に分割できるようになった。→ 機能分割が可能になった。

# オブジェクト指向プログラミング

カプセル化、継承、ポリモーフィズムで特徴づけられるプログラミングパラダイム。

## カプセル化

**情報隠蔽**とも呼ばれる。データとそれを扱う操作をひとまとまりにしたもの。その外側にはデータが見えないようになっていて（プライベートメンバー）、一部の関数だけを外部から呼ぶことができる（パブリックなメンバー関数）。

ただしこれは非 OO 言語でも実現でき、かつ C++などの OO 言語では完璧なカプセル化は破られている。

## 継承

> スコープ内の変数と関数グループを再度宣言したもの
>
> _- Clean Architecture_

## ポリモーフィズム

polymorphic(多態性) = poly(複数に) + morphic(変化する)
呼び出す対象によって振る舞いが決まる。一方で呼び出し側は共通の同一のプロトコルを利用できる。

### UNIX でのポリモーフィズム

UNIX は IO デバイスの非依存性をサポートするプラグインアーキテクチャを採用している。だが、その考え方をプログラムに汎用的に適用することはなかった。OO の登場によって、プラグインアーキテクチャを安全に使えるようになった。

<!-- なんで安全になった？ -->

### 依存関係の逆転

ポリモーフィズム以前のソースコードの依存関係は、上位レベルの関数が中間のレベルの関数を呼び出し、その関数が更に下位の関数を呼ぶように、制御の流れと同じになっている。

ソースコードの依存関係 = 制御の流れ

ポリモーフィズムを活用することで、モジュール間にインターフェースを挿入することによって依存関係を逆転することが可能になった。各モジュールがインターフェースに依存しているので、インターフェースの要件さえ満たせば、各モジュールはそのレイヤーに関係なく互いに独立させることができる。（低結合の実現）。

> インターフェースに依存した汎用処理として記述すれば、結合度が下がり、テストが書きやすくなったり、仕様変更に強くなったりする。
>
> _- [新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡](https://qiita.com/hirokidaichi/items/591ad96ab12938878fe1)_

OO とは何か？ソフトウェアアーキテクト的には

> 「ポリモーフィズムを使用することで、システムにある全てのソースコードの依存関係を絶対的に制御する能力」である
>
> _- Clean Aarchitecture_

# 関数型プログラミング

関数型言語の変数は変化しない（=再代入がない）。
可変変数によって生じる、競合状態や並行更新といった問題が生じない。

## 可変性の分離

アプリケーションを可変コンポーネントと不変コンポーネントに分離することで不変性を妥協する。

不変コンポーネントでは可変変数は使わず純粋に関数的タスクを行い。一つ以上の可変コンポーネントと通信する。
可変コンポーネントでは可変関数を使うことができるが、並行更新や競合状態から保護するために**トランザクショナルメモリ**を使用する。

## イベントソーシング

状態ではなく取引（トランザクション）を保存する戦略。すべての取引を収集することで必要な状態を得ることができる。この仕組みに必要なデータストレージを考えた場合、データストアに対する削除や更新は行われない。生成と読み込みだけが行われることになる。（CRUD の CR のみ）。並行更新の問題も発生しない。Git のような考え方。

# まとめ

- 構造化プログラミングは、直接的な制御の移行に規律を課すもの。
- オブジェクト指向プログラミングは、間接的な制御の移行に規律を課すもの。
- 関数型プログラミングは、代入に規律を課すもの。

ソフトウェアは順次、選択、反復、間接参照で構成されている。

# 参考

- [Clean Architecture](https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656)
- [goto 文とは｜ goto 文はなぜ禁止されるのか【goto 文と教養】](https://marycore.jp/coding/why-goto-statement-is-bad/#goto%E6%96%87%20%E4%B8%8D%E8%A6%81%E8%AB%96)
- [新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡](https://qiita.com/hirokidaichi/items/591ad96ab12938878fe1)
- [オブジェクト指向技術の基本概念](https://www.ogis-ri.co.jp/otc/hiroba/technical/concept.html)
- [並行性の問題](https://www.ibm.com/docs/ja/db2/11.1?topic=design-concurrency-issues)
- [【Haskell で学ぶ】関数型言語とは何か？](https://zenn.dev/masahiro_toba/books/a808e953a39110/viewer/33a367)
- [世界一わかりやすい Clean Architecture](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)
